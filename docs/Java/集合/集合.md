# java中的集合

单列：存放单个对象，像是一个个独立的元素排队

双列：存放键值对，像字典一样，通过词查找解释



## 单列集合：List接口和Set接口

List接口（有序，可重复）

ArrayList：动态数组

特点是查询的快，增删的慢

扩容机制是，初始为10，每次扩大为原来的1.5



LinkedList：双向链表

特点是增删快，查询的慢



Vector：数组

安全版本的ArrayList，方法带synchronized



Set接口：（无序，不可重复）

注意：只需要搞懂Map，那么Set就是在Map的基础上，将所有的value设置为了指向同一个对象



HashSet：底层为HashMap（允许null）

特点是无序，去重



LinkedHashSet：底层为LinkedHashMap（允许null）

虽然是Set，但是维护了一个链表来记录插入顺序，所以便利顺序和插入顺序一致



TreeSet：底层是TreeMap

特点：可以排序，添加元素时会感觉你指定的排序规则自动排序



## 双列集合：Map接口

HashMap（允许null）

key不允许重复，value可以重复。key和value都可以为null。线程不安全。

底层机制：数组+链表+红黑树、当链表元素超过8个且数组长度超过64时，链表会转为红黑树来提升查询速率

非线程安全

计算hash数值，对null做了判断，如果是null，就直接返回为0



LinkedHashMap(允许null)

再HashMap上面，维护了一个双向链表，记录插入的顺序，因此对该容器进行访问的时候，就会参考顺序对其进行访问



Hashtable：

线程安全，key和value都不能为null，效率比较低

不允许null，是因为会产生二义性。

比如说，这个key的value是null，但是当你get得到后，你无法确定这到底是代表的为空还是不在容器中。就要使用containsKey进行检验，但是这个样子就会导致多线程的问题。因此就在设计HashTable的时候，直接禁止了null的kv。

第二个原因，hashtable在计算哈希数值的时候，是直接调用了key对象的hashcode函数，因为没有做非空判断，所以key不能为null



TreeMap

可以按照key进行排序

底层使用了红黑树
