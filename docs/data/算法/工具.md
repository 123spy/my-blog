# C++ STL手册

## :full_moon:vector

### 常用函数：

push_back(): 尾部插入

pop_back(): 尾部删除。

reserve(n): 防 TLE 技巧。提前分配内存，避免扩容时的拷贝开销。

unique(): 去重，需配合sort()使用，去重后需erase()尾部垃圾。

resize(): 重置大小并初始化。



### 扩展：sort()排序 + unique()去重 + erase()擦除

#### 为什么必须先sort()排序？

unique()的工作原理：它只比较**相邻**的两个元素，如果 `v[i] == v[i-1]`，它就认为这是重复的。

如果不排序：

> 数组：[1, 2, 1, 3] unique扫过去：1和2不等，2和1不等，1和3不等。 **结果：** 它认为没有重复！

如果排序后：

> 数组：[1, 1, 2, 3] unique扫过去：发现两个1相邻，逮到了！



#### 什么是 "尾部垃圾"？

unique()不会改变容器的大小(size)！它也不会真的释放内存。

它的做法是：**把不重复的元素移到数组的前面，剩下的位置就不管了。**

```
unique()前： [1, 1, 2, 2, 3, 3]


unique()后：
数值: [1,  2,  3,  ?,  ?,  ?]
          ^        ^
          |        |
       有效数据  it(返回的迭代器)
```

it指向了**有效数据**的**下一个位置**。

从it开始到结尾的数据依然存在，通常是原来数组里的旧数据（在 C++ 标准中这部分数据的值是“未定义”的，但通常是原来的值或被移动后的残留值）。

这就是所谓的“尾部垃圾”。

size还是**原来的大小**，如果你这时候打印 vector，可能会看到[1 2 3 2 3 3]这种奇怪的东西。



#### 如何真的删除？

因为unique()返回了一个迭代器it，指向了垃圾数据的**起点**。 我们要做的就是从 it 开始，一直删到 v.end()。

```c++
sort(v.begin(), v.end());
v.erase(unique(v.begin(), v.end()), v.end());
```



## deque

### 核心函数：

- push_front(val)：头部插入
- pop_front()：头部删除。
- push_back(val)：尾部插入
- pop_back()：尾部删除。



## :full_moon:set

### 特征：

存储 Key。按Key**排序**，Key唯一。

### 核心函数：

- :full_moon:insert(val)：插入。
- :full_moon:count(val)：查存在性（0或1）。
- lower_bound(val)：返回首个 >= val的迭代器。
- upper_bound(val)：返回首个 > val的迭代器。



## :full_moon:map

### 特征：

存储Key-Value对。按Key排序，Key唯一。

### 核心函数：

operator[x]: 访问或修改。



**注意**：如果x不存在，会进行以下操作：

插入一个键为 `x` 的新元素。

对该键对应的 **Value 进行初始化**（通常是调用默认构造函数，比如 `int` 会变成 `0`，`string` 会变成空串）。

返回这个新创建 Value 的引用。



解决方案：

- 使用 `.count(x)` (最简单)

- 使用 `.find(x)` (最高效)

- 使用 `.contains(x)` (C++20 新特性)



## multiset

核心函数接口

- insert(val)      // 插入元素，总是成功（因为允许重复）
- find(val)        // 返回首个等于 val 的迭代器
- count(val)       // 返回 val 出现的次数 O(logN + count)
- erase(val)       // 删除所有 val
- erase(it)        // 删除迭代器指向的元素



## :full_moon:unordered_set

注：与set相似，但是不会对其进行排序。



## :full_moon:unordered_map

注：与map相似，但是不会对其进行排序。



## priority_queue

### 核心函数：

- push(val): 加入。
- top(): 看堆顶（最大的）。
- pop(): 删堆顶。



常规使用：

```c++
// 大根堆(默认)
priority_queue <int,vector<int>,greater<int> > q;

// 小根堆
priority_queue <int,vector<int>,less<int> >q;
```



结构体实现小根堆，需重载<运算符号

```C++
struct Point {
    int x, y;
    // 想要按 x 升序
    bool operator<(const Point& other) const {
        return x < other.x;
    }
};
vector<Point> v;
sort(v.begin(), v.end()); // 按 x 从小到大排
```

